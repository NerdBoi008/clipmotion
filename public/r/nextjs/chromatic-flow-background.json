{
  "name": "chromatic-flow-background",
  "type": "registry:component",
  "description": "A flowing, chromatic background that paints dynamic trails as the cursor moves.",
  "files": [
    {
      "name": "chromatic-flow-background.tsx",
      "content": "\"use client\";\n\nimport { useEffect, useRef, useCallback } from \"react\";\nimport { cn } from \"@/components/utils\";\n\n/**\n * @description A flowing, chromatic background that paints dynamic trails as the cursor moves.\n * @category Hover Effects\n * @source https://www.instagram.com/reel/DSR2twIDEsu\n * @author nerdboi008\n * @github https://github.com/NerdBoi008\n * @x https://x.com/moin_malek_\n * @website https://www.nerdboi.online\n */\n\ninterface ChromaticFlowBackgroundProps {\n  className?: string;\n  lineWidth?: number;\n  speed?: number;\n  trailLength?: number;\n  hueSpeed?: number;\n  baseHue?: number;\n  saturation?: number;\n  lightness?: number;\n  opacity?: number;\n  fadeTrail?: boolean;\n  enabled?: boolean;\n}\n\nexport default function ChromaticFlowBackground({\n  className,\n  lineWidth = 250,\n  speed = 0.12,\n  trailLength = 50,\n  hueSpeed = 1,\n  baseHue = 0,\n  saturation = 90,\n  lightness = 60,\n  opacity = 0.9,\n  fadeTrail = true,\n  enabled = true,\n}: ChromaticFlowBackgroundProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const mouse = useRef({ x: 0, y: 0 });\n  const trail = useRef<{ x: number; y: number }[]>([]);\n  const animationId = useRef<number>(0);\n  const globalHue = useRef(0); // Global hue that continuously animates\n\n  const getContext = useCallback((canvas: HTMLCanvasElement) => {\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n      ctx.imageSmoothingEnabled = false;\n      return ctx;\n    }\n    return null;\n  }, []);\n\n  const resize = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    canvas.width = rect.width * window.devicePixelRatio;\n    canvas.height = rect.height * window.devicePixelRatio;\n  }, []);\n\n  const drawTrail = useCallback((ctx: CanvasRenderingContext2D) => {\n    if (!enabled || trail.current.length === 0) return;\n\n    // Continuous global hue animation\n    globalHue.current = (globalHue.current + hueSpeed) % 360;\n\n    // Fade trail effect\n    if (fadeTrail) {\n      ctx.fillStyle = `rgba(255, 255, 255, 0.1)`;\n      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    }\n\n    ctx.save();\n    ctx.lineCap = \"round\";\n    ctx.lineJoin = \"round\";\n    ctx.lineWidth = lineWidth;\n    ctx.shadowBlur = 10;\n    ctx.shadowColor = `hsla(${globalHue.current}, ${saturation}%, ${lightness}%, ${opacity})`;\n\n    ctx.beginPath();\n    \n    // Draw trail with gradient hues based on globalHue\n    trail.current.forEach((point, i) => {\n      const trailProgress = (i + 1) / trail.current.length;\n      const hueOffset = (trailProgress * 60) % 360; // Rainbow gradient along trail\n      const hue = (globalHue.current + hueOffset + baseHue) % 360;\n      const alpha = fadeTrail ? trailProgress * opacity : opacity;\n      \n      ctx.globalAlpha = alpha;\n      ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;\n      \n      if (i === 0) {\n        ctx.moveTo(point.x, point.y);\n      } else {\n        ctx.lineTo(point.x, point.y);\n      }\n    });\n\n    ctx.stroke();\n    ctx.restore();\n  }, [enabled, lineWidth, fadeTrail, baseHue, saturation, lightness, opacity, hueSpeed]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = getContext(canvas);\n    if (!ctx) return;\n\n    resize();\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = canvas.getBoundingClientRect();\n      mouse.current.x = (e.clientX - rect.left) * window.devicePixelRatio;\n      mouse.current.y = (e.clientY - rect.top) * window.devicePixelRatio;\n    };\n\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    window.addEventListener(\"resize\", resize);\n\n    const animate = () => {\n      if (!enabled) {\n        animationId.current = requestAnimationFrame(animate);\n        return;\n      }\n\n      // Update mouse position with smoothing\n      const targetX = mouse.current.x;\n      const targetY = mouse.current.y;\n      const current = trail.current[0] || { x: targetX, y: targetY };\n      \n      const newX = current.x + (targetX - current.x) * speed;\n      const newY = current.y + (targetY - current.y) * speed;\n\n      // Add new trail point\n      trail.current.unshift({ x: newX, y: newY });\n\n      // Limit trail length\n      if (trail.current.length > trailLength) {\n        trail.current.pop();\n      }\n\n      // Clear and redraw with continuous color animation\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      drawTrail(ctx);\n\n      animationId.current = requestAnimationFrame(animate);\n    };\n\n    animate();\n\n    return () => {\n      cancelAnimationFrame(animationId.current);\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n      window.removeEventListener(\"resize\", resize);\n    };\n  }, [resize, getContext, drawTrail, enabled, speed, trailLength]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={cn(\n        \"fixed inset-0 z-[-1] blur-2xl h-screen w-screen pointer-events-none\",\n        className\n      )}\n    />\n  );\n}"
    }
  ],
  "dependencies": [
    "next",
    "react"
  ],
  "devDependencies": [],
  "registryDependencies": [
    "utils"
  ],
  "meta": {
    "source": "https://www.instagram.com/reel/DSR2twIDEsu",
    "category": "Hover Effects",
    "contributor": {
      "name": "nerdboi008",
      "github": "https://github.com/NerdBoi008",
      "x": "https://x.com/moin_malek_",
      "website": "https://www.nerdboi.online"
    }
  }
}